/**
 * Netlify Function v2 — Email PDF Endpoint
 *
 * Accepts a PDF (base64-encoded) plus recipient/subject/body,
 * and sends the email via Resend's REST API.
 *
 * No sensitive data stored — API key lives in Netlify env vars only.
 *
 * Set RESEND_API_KEY in Netlify dashboard to activate.
 * Optionally set EHC_EMAIL_FROM for custom sender address.
 */

interface EmailRequest {
  to: string;
  cc?: string;
  subject: string;
  body: string;
  pdfBase64: string;
  filename: string;
  /** When true, body is wrapped in branded HTML template */
  htmlEnabled?: boolean;
}

interface EmailResponse {
  ok: boolean;
  messageId?: string;
  error?: string;
}

function getEnv(key: string): string {
  try {
    // @ts-expect-error Netlify global is injected at runtime
    return Netlify.env.get(key) || '';
  } catch {
    return process.env[key] || '';
  }
}

// Simple in-memory rate limiter (per function instance)
const rateLimitMap = new Map<string, number[]>();
const RATE_LIMIT_WINDOW_MS = 60_000; // 1 minute
const RATE_LIMIT_MAX = 5; // max 5 emails per minute per IP

function isRateLimited(ip: string): boolean {
  const now = Date.now();
  const timestamps = rateLimitMap.get(ip) || [];
  const recent = timestamps.filter(t => now - t < RATE_LIMIT_WINDOW_MS);
  if (recent.length >= RATE_LIMIT_MAX) {
    rateLimitMap.set(ip, recent);
    return true;
  }
  recent.push(now);
  rateLimitMap.set(ip, recent);
  return false;
}

function isValidEmail(email: string): boolean {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}

/** Escape HTML entities to prevent XSS in email body content. */
function escapeHtml(text: string): string {
  const map: Record<string, string> = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
  };
  return text.replace(/[&<>"']/g, char => map[char]);
}

/**
 * Wrap plain-text body in a branded HTML email template.
 * Table-based layout for email client compatibility. All CSS inline.
 */
function buildHtmlEmail(body: string): string {
  const bodyHtml = escapeHtml(body).replace(/\n/g, '<br>');
  return `<!DOCTYPE html>
<html lang="en">
<head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"></head>
<body style="margin:0;padding:0;background-color:#f3f4f6;font-family:Arial,Helvetica,sans-serif;">
<table role="presentation" width="100%" cellpadding="0" cellspacing="0" style="background-color:#f3f4f6;">
<tr><td align="center" style="padding:24px 16px;">
<table role="presentation" width="600" cellpadding="0" cellspacing="0" style="max-width:600px;width:100%;background-color:#ffffff;border-radius:8px;overflow:hidden;box-shadow:0 1px 3px rgba(0,0,0,0.1);">
  <!-- Header -->
  <tr>
    <td style="background-color:#1a3a4a;padding:20px 32px;">
      <table role="presentation" width="100%" cellpadding="0" cellspacing="0">
        <tr>
          <td style="color:#ffffff;font-size:20px;font-weight:bold;letter-spacing:0.5px;">
            Executive Home Care
          </td>
        </tr>
      </table>
    </td>
  </tr>
  <!-- Accent bar -->
  <tr>
    <td style="background-color:#d4912a;height:4px;font-size:0;line-height:0;">&nbsp;</td>
  </tr>
  <!-- Body -->
  <tr>
    <td style="padding:32px;color:#374151;font-size:14px;line-height:1.6;">
      ${bodyHtml}
    </td>
  </tr>
  <!-- Footer -->
  <tr>
    <td style="background-color:#f9fafb;padding:20px 32px;border-top:1px solid #e5e7eb;">
      <table role="presentation" width="100%" cellpadding="0" cellspacing="0">
        <tr>
          <td style="color:#9ca3af;font-size:12px;line-height:1.5;">
            EHC Assessments &amp; Contracts<br>
            This email was generated by Executive Home Care.
          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
</td></tr>
</table>
</body>
</html>`;
}

function jsonResponse(body: EmailResponse, status: number): Response {
  return new Response(JSON.stringify(body), {
    status,
    headers: { 'Content-Type': 'application/json' },
  });
}

export default async (req: Request) => {
  // Only allow POST
  if (req.method !== 'POST') {
    return jsonResponse({ ok: false, error: 'Method not allowed' }, 405);
  }

  // Check API key exists (master switch)
  const apiKey = getEnv('RESEND_API_KEY');
  if (!apiKey) {
    return jsonResponse({ ok: false, error: 'Email service not configured' }, 503);
  }

  // Rate limiting
  const clientIp = req.headers.get('x-forwarded-for')?.split(',')[0]?.trim() || 'unknown';
  if (isRateLimited(clientIp)) {
    return jsonResponse({ ok: false, error: 'Rate limit exceeded. Try again in a minute.' }, 429);
  }

  // Parse request body
  let payload: EmailRequest;
  try {
    payload = await req.json() as EmailRequest;
  } catch {
    return jsonResponse({ ok: false, error: 'Invalid request body' }, 400);
  }

  const { to, cc, subject, body, pdfBase64, filename, htmlEnabled } = payload;

  // Validate required fields
  if (!to || !subject || !body || !pdfBase64 || !filename) {
    return jsonResponse(
      { ok: false, error: 'Missing required fields: to, subject, body, pdfBase64, filename' },
      400,
    );
  }

  if (!isValidEmail(to)) {
    return jsonResponse({ ok: false, error: 'Invalid recipient email address' }, 400);
  }

  if (cc && !isValidEmail(cc)) {
    return jsonResponse({ ok: false, error: 'Invalid CC email address' }, 400);
  }

  // Content size limits — prevent abuse via oversized subject/body
  if (subject.length > 1_000) {
    return jsonResponse({ ok: false, error: 'Subject too long (max 1000 characters)' }, 413);
  }
  if (body.length > 50_000) {
    return jsonResponse({ ok: false, error: 'Email body too long (max 50000 characters)' }, 413);
  }

  // Max payload size check (~5.5MB base64 ≈ ~4MB PDF)
  // Netlify Functions have a 6MB request body limit on the default tier
  if (pdfBase64.length > 5_500_000) {
    return jsonResponse({ ok: false, error: 'PDF attachment too large (max 4MB)' }, 413);
  }

  // Build Resend API payload
  const fromEmail = getEnv('EHC_EMAIL_FROM') || 'EHC Assessments & Contracts <noreply@ehcassessment.com>';

  // Build HTML content — branded template when enabled, simple line-break conversion otherwise
  // Both paths escape HTML entities to prevent XSS
  const htmlContent = htmlEnabled !== false
    ? buildHtmlEmail(body)
    : escapeHtml(body).replace(/\n/g, '<br>');

  const resendPayload: Record<string, unknown> = {
    from: fromEmail,
    to: [to],
    subject,
    html: htmlContent,
    attachments: [
      {
        filename,
        content: pdfBase64,
      },
    ],
  };

  if (cc) {
    resendPayload.cc = [cc];
  }

  // Send via Resend REST API
  try {
    const response = await fetch('https://api.resend.com/emails', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(resendPayload),
    });

    if (!response.ok) {
      const errorText = await response.text().catch(() => 'Unknown error');
      return jsonResponse(
        { ok: false, error: `Email service error (${response.status}): ${errorText.slice(0, 200)}` },
        502,
      );
    }

    const result = await response.json() as { id?: string };

    return jsonResponse({ ok: true, messageId: result.id }, 200);
  } catch {
    return jsonResponse({ ok: false, error: 'Failed to connect to email service' }, 502);
  }
};

export const config = {
  path: '/api/email',
};
